# 浅拷贝
定义:'它复制的只是表面的一层,对象里面再有对象就复制不了而是改变内存地址'

```

<script>
   const zhy = {
     name:"zhy",
     age:'24',
     content:'真帅'
   }
   /* 方法一  最简单直接解构*/
   const zhy2 ={...zhy}
   zhy2.age = '25'
   console.log(zhy)  
   /* 方法二 for 循环 */
   const zhy3 ={}
   for (const key in zhy) {
      zhy3[key]=zhy[key]
   }
   zhy3.age = '25'
   console.log(zhy)
   /* 使用对象方法 assign:把2个对象合并成一个对象 */
   const zhy4 = Object.assign({},zhy)
    zhy4.age = '25'
   console.log(zhy)
 
</script>
```
总结:'各有各的优缺点结合实际业务选择最合适的方法'

# 深拷贝
定义:浅拷贝只能改变表面一层的，如果说对象里面有数组或者说是对象的话，用上面的方法就没有全部赋值成功
所以深拷贝就很有必要,实现原理主要就是递归
```

<script>
   const obj ={
     name:'zhy',
     city:{
       first:'帝景苑',
       two:'恒禾七尚'
     },
     content:"钻石王老五",
     wife:['美女','富婆']
   }
   function life (obj){
     const zhy2 = obj instanceof Object?{}:[]
     for (const key of Object.ownKeys(obj)) {
          zhy2[key] = typeof obj[key] == 'object'? life(obj[key]):obj[key]
     }
     return zhy2
   }
   const zhy2 = life(obj)
   zhy2.wife[0] = '丑女'
   zhy2.city.two ='城中村'
   console.log(obj)
   console.log(zhy2)
</script>
```

这就是深拷贝也太简单了

# 总结
上面只是简单的实现了功能 但是对象里面还可能会有对象 symbol（Object.ownKeys） 正则 日期 map set 环引用（weakmap）等（这种直接引用写好的库）
简单的 深拷贝值用 json 转